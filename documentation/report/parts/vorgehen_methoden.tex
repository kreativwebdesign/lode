%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../doc"
%%% coding: utf-8
%%% End:
% !TEX TS-program = pdflatexmk
% !TEX encoding = UTF-8 Unicode
% !TEX root = ../doc.tex
\section{Vergleich LOD Systeme}
Die verschiedenen LOD Systeme sowie ihre Vor- und Nachteile werden in \autoref{chap:differentLodApproaches} erläutert. In diesem Schritt wird erläutert, welche Art LOD System in dieser Arbeit entwickelt werden soll.

Die verschiedenen Ansätze unterscheiden sich in einigen Kriterien. Für den Einsatz in einer Webanwendungen ist die Gewichtung der Kriterien anders als für Desktopanwendungen, Spiele oder dergleichen.
So hat die Dateigrösse der Modelle bei Webanwendungen einen grösseren Einfluss auf die gefühlte Performanz beim Endanwender. Insofern ist die Auswirkung der gewählten Strategie auf die Downloadgrösse ein wichtiges Kriterium. Für diskrete LOD muss für jedes Level ein separates Modell geladen werden. Dies erhöht die Downloadgrösse merkbar. Bei kontinuierlichen LOD Systemen muss das Modell die Unterschiede zwischen verschiedenen Levels persistieren. Mit einem für kontinuierliche LOD ausgelegten Algorithmus kann der benötigte Speicher reduziert werden, indem beim \e{Edge Collapse} nicht auf einen neuen optimalen \e{Vertex} reduziert wird, sondern von den beiden bestehenden \e{Vertices} der passendere gewählt wird. Trotzdem entsteht für jeden \e{Edge Collapse} ein zusätzlicher Speicheraufwand.
Insbesondere unter Berücksichtigung der Tatsache, dass Laufzeitperformanz essentiell für Webanwendungen ist, wurde entschieden nicht auf kontinuerliche LOD Systeme zu setzen.
Zudem wurde entschieden kein hierarchisches LOD System zu entwickeln, um die Integration des Tools für die Entwickler einer Webanwendung möglichst einfach zu gestalten.
Das diskrete LOD System ist für Grafiker und Entwickler die einfachste zu verwenden und deckt somit auch die breiteste Benutzerbasis und die meisten Anwendungsfälle ab. Aufgrund dessen, wird im Rahmen dieser Arbeit ein Algorithmus dieses Systems entwickelt und in den Entwicklungsprozess integriert.
Eine Übersicht über die verschiedenen Kriterien kann in Tabelle \ref{table:lodSystemComparison} gefunden werden.

\begin{table}[H]
  \centering
  \begin{tabular}{||p{8cm} c c c||}
  \hline
  \textbf{Technische Auswirkungen} & DLOD & CLOD & HLOD \\
  \hline
  Auswirkung auf Downloadgrösse & mittel & mittel & mittel \\
  Auswirkung auf Laufzeitverhalten & klein & mittel & mittel \\
  Auswirkung auf \e{Scene Graph} & lokal & lokal & global \\
  "Visual Pop" vermeidbar & nein & ja & ja \\
  Integration in bestehende Arbeitsabläufe & einfach & einfach & umständlich \\
  \hline
  \textbf{Möglichkeiten} &  &  &  \\
  \hline
  Drastische Reduktion von Polygonen & ja & ja & ja \\
  Clustering möglich & nein & nein & ja \\
  \hline
  \end{tabular}
  \caption{Übersicht Merkmale der verschiedenen LOD Systeme}
  \label{table:lodSystemComparison}
\end{table}

\section{Surface Simplification Algorithmus}
Die verschiedenen Klassen von Algorithmen werden in \autoref{chap:lodAlgorithmComparison} kurz erläutert.

Verschiedene Algorithmen wurden für die Implementierung in Betracht gezogen. Die wohl weitverbreiteste Art ist der von Garland und Heckbert 1997 definierte \e{Surface Simplification using Quadric Error Metrics} welcher auf \e{Edge Collapses} basiert.
\cite{surfaceSimplificationUsingQuadricErrorMetrices}

Der Algorithmus kann wie folgt zusammengefasst werden:

\begin{enumerate}
  \item Fehlermetrik für alle Vertices berechnen.
  \item Optionen für \e{Edge Collapse} markieren.
  \item Optionen mit geringstem Fehler optimieren.
\end{enumerate}

\subsection{Fehlermetrik}
Das Ziel der Fehlermetrik ist es eine Heuristik zu definieren, welche den geometrischen Unterschied zwischen dem vereinfachten und dem originalen Modell beschreibt.
Mithilfe der Fehlermetrik können anschliessend die Transformationen am Modell gemäss den kleinsten Kosten optimiert werden. Der Algorithmus funktioniert grundsätzlich unabhängig von der gewählten Fehlermetrik. So könnten verschiedene Metriken eingesetzt werden.
Die hier gewählte Metrik definiert den Fehler mithilfe einer symmetrischen $4\times 4$ Matrix. Die Matrix repräsentiert die Distanz eines \e{Vertices} zu einer zugehörigen \e{Face}. Für die Kombination mehrerer \e{Faces} können die Matrizen addiert werden.

Beim Entfernen einer \e{Edge} werden die Fehlermetriken der zugehörigen \e{Vertices} addiert.

\section{Pipeline Integration}
Die Lösung soll in eine wiederverwendbare und konfigurierbare Pipeline integriert werden.
In der Webentwicklung ist es üblich, über \fgls{CLI}{Command Line Interface – Kommandozeile} Arbeitsschritte zu automatisieren. Es soll demnach ein \e{\gls{CLI}} erstellt und auf \fgls{NPM}{Node Package Manager} öffentlich zugänglich gemacht werden, welches nahtlos in den Entwicklungsablauf integriert werden kann. Über eine Konfiguration soll angegeben werden können, wo nach den \e{.glTF} Dateien gesucht, wie die Output-Dateien benennt und in welchem Modus das Tool gestartet werden soll. Ebenso werden Algorithmus-Einstellungen in dieser Konfiguration gesetzt werden können. Es soll einfach zu bedienen, gut dokumentiert und gut gewählte Standardeinstellungen haben. Zudem soll das Tool im einmal Modus laufen können oder kontinuierlich sich ändernde Dateien neu optimieren.

\section{Nutzen LOD}
Um den Nutzen von LOD quantifizieren zu können, wird in einer ersten Phase ein Benchmark aufgestellt.
Ziel ist es, das Laufzeitverhalten unter Einsatz eines optimierten Modells zu analysieren und somit den maximal möglichen Einfluss von LOD auf die Leistung klassifizieren zu können.

\subsection{Aspekte für Nutzen}

Der Nutzen eines Systems definiert sich durch eine Vielzahl von Aspekte welche in verschiedenen Phasen aufgeteilt werden können. Die verschieden für die Entwicklung von Webanwendungen relevanten Aspekte werden im folgenden Abschnitt erläutert. Selbstverständlich kann nicht auf alle Aspekte eingegangen werden, es werden lediglich die relevantesten berücksichtigt.

\paragraph{Entwicklungszeit}

Entwicklungszeit beziffert den Aufwand für die Entwicklung einer Anwendung und kann häufig direkt in Arbeitsstunden beziffert werden.
Die Auswirkungen eines Systems auf die Entwicklungszeit ist entscheidend dafür, ob etwas eingesetzt werden kann. Ein System mit riesigem Nutzen für die Laufzeit im Browser, welches jedoch signifikanten Mehraufwand für die Entwicklungszeit bedeutet wird in der Praxis keine grosse Bedeutung finden da Entwicklungskosten hoch sind.

\paragraph{Download}

Die Downloadzeit ist grundsätzlich linear abhängig von der Dateigrösse.
Je grösser die Dateien, desto mehr Bandbreite wird verwendet. Dies hat direkte Auswirkungen auf die Zeit bis eine Anwendung benutzt werden kann. Ziel ist es die Downloadgrösse möglichst tief zu halten.
Dank der heutigen Bandbreiten ist dies für viele Anwendungsbereiche ein kleinerwerdendes Problem.
Zudem können Probleme in diesem Bereich teilweise kaschiert werden indem man das Ladeverhalten optimiert. Häufig sind nicht alle Artefakte notwendig um eine verwendbare Anwendung darzustellen und der Rest kann phasenweise nachgeladen werden.
Ausserdem ist es auch möglich Artefakte bereits vorzuladen.

\paragraph{Laufzeit}

Entscheidend ist, unabhängig von der Applikation, das Laufzeitverhalten. Eine Applikation, welche eine schlechte User Experience liefert ist inakzeptabel.
Das Laufzeitverhalten wird durch eine Vielzahl von Aspekten beeinflusst.
Angestrebt werden grundsätzlich immer 60 \fgls{FPS}{Frames per Second. Bilder pro Sekunde. Gängige Art, die Performanz der \gls{Rendering Engine} zu messen}. Wenn eine bestimmte Szenerie diese 60 \e{\gls{FPS}} nicht erreicht ist ein Performanzproblem vorhanden.

\paragraph{Benchmarkaspekte}
In dieser Arbeit wird ein hoher Wert darauf gelegt, dass die Entwicklungszeit möglichst geringfügig verändert wird. Zudem werden, wo möglich, Empfehlungen getätigt um die Downloadgrösse möglichst marginal zu verändern.
Die somit primären Aspekte für die Beurteilung sind die Auswirkungen auf das Laufzeitverhalten.

\subsection{Mögliche Ansätze}

Verschiedene Varianten können gewählt werden um den Nutzen aufzuzeigen. Die verschiedenen in Betracht gezogenen Ansätze werden in diesem Abschnitt erläutert.

\paragraph{Modellbetrachtung}
Grundsätzlich kann der Nutzen einfach beziffert werden indem die Kosten zum Rendering eines Modelles berechnet werden. So können die Kosten in benutzter GPU Ressourcen gemessen werden indem man die Kosten eines spezifischen \e{Draw Calls} misst. Diese Art von Benchmark ist relativ einfach zu implementieren und liefert genaue Resultate. Die Auswirkungen von Nebeneffekten können beinahe vollständig negiert werden.
Sinnvoll wäre es das Modell in konstanter Distanz zur Kamera um zwei Achsen drehen zu lassen und die Messung solange durchzuführen, bis eine ganze Umdrehung stattgefunden hat.
Der primäre Nachteil bei dieser Variante liegt an der Aussagekraft. Die einzige belegte Aussage ist, dass es möglich ist Performanzeinsparungen mit Vereinfachungen zu erhalten. Dies dient jedoch nicht als Beleg, dass der Einsatz von LOD Artefakten Performanzengpässe lösen kann.

\paragraph{Szeneriebetrachtung}
Bei diesem Ansatz wird eine gegebene Szenerie möglichst geringfügig angepasst und die Auswirkungen auf die Performanz verglichen.
Wenn die unoptimierte Variante 60 \e{\gls{FPS}} erreicht oder gar übersteigt, ist eine Optimierung nicht notwendig. Somit muss eine Szenerie gewählt werden, welche diesen Wert unterschreitet. 
Ziel ist es dann die LOD Artefakte in dieselbe Szenerie zu integrieren und die \e{FPS} zu steigern. Ziel der Arbeit ist es, ein System zu entwickeln, das für Szenarien unter 60 \e{\gls{FPS}} diese erhöht und im Idealfall auf ebendiesen Wert hebt.
Eine solche Szenerie soll grundsätzlich Modelle sowohl nah als auch in grosser Distanz zeigen. Ein Beispiel für eine solche Szenerie ist eine Visualisierung aus  Vogelperspektive mit Zoom Verhalten.
Die Aussagekraft eines solchen Tests ist ausreichend um einen Beleg für den positiven Nutzen des Systems zu haben.

\subparagraph{Vergleichbare Arbeiten}
Eine unabhängige Arbeit definierte 2017 einen vergleichbaren Benchmark um die Performanz von Three.js und Babylon.js in einem spezifischen Anwendungsgebiet zu vergleichen. Der Benchmark entwickelte vergleichbare Szenerien und vergleicht die Ressourcennutzung der beiden Varianten. \cite{performanceComparisonBabylonThreejs}
